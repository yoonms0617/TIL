# 영속성 컨텍스트(Persistence Context)

엔티티를 영구 저장하는 환경이다.

- 영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다.
- 영속 상태는 식별자 값이 반드시 있어야 한다. (식별자 값이 없으면 예외 발생)
- JPA는 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이를 플러시(flush)라 한다.

영속성 컨텍스트가 엔티티를 관리하면 다음과 같은 장점이 있다.

- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연 로딩

## 1차 캐시

영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이를 1차 캐시라고 한다.

```java
Member member = new Member(1L, "yoon");

// 엔티티를 영속
em.persist(member);

// 1차 캐시에서 조회
em.find(Member.class, 1L);
```

- 영속 상태의 엔티티는 모두 1차 캐시에 저장된다.

영속성 컨텍스트 내부에 Map이 하나 있고 키는 식별자 값이고 값은 엔티티 인스턴스라고 생각하면 쉽다.

```text
   | 1차 캐시 |
*-------*--------*
|  @Id  | Entity |
*-------*--------*
|  1L   | Member |
*-------*--------*
```

- 1차 캐시의 키는 식별자 값이다. 식별자 값은 데이터베이스 기본 키와 매핑되어 있다.
- 영속성 컨텍스트에 데이터를 저장하고 조회하는 모든 기준은 데이터베이스 기본 키 값이다.
- 우선 1차 캐시에서 식별자 값으로 엔티티를 찾는다. 찾는 엔티티가 있다면 데이터베이스를 조회하지 않고 메모리에 있는 1차 캐시에서 엔티티를 조회한다.
- 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해 엔티티를 생성한 후 1차 캐시에 저장한 뒤 영속 상태의 엔티티를 반환한다.

## 동일성 보장

```java
Member memberA = em.find(Member.class, 1L);
Member memberB = em.find(Member.class, 1L);

// true
System.out.println(memberA == memberB);
```

- em.find(Member.class, 1L)를 반복해서 호출해도 영속성 컨텍스트는 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다.
- 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.

## 트랜잭션을 지원하는 쓰기 지연

```java
tx.begin();   // 트랜잭션 시작

em.persist(memberA);
em.persist(memberB);
// INSERT SQL을 데이터베이스에 보내지 않는다.

tx.commit();  // 커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다.
```

엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않는다.

- 내부 쿼리 저장소에 INSERT SQL을 쌓아둔 다음 트랜잭션을 커밋할 때 모두안 쿼리를 데이터베이스에 보낸다. (트랜잭션을 지원하는 쓰기 지연)
- 영속성 컨텍스트는 1차 캐시에 엔티티를 저장하면서 동시에 엔티티 정보로 등록 쿼리를 생성한다. 만들어진 등록 쿼리는 쓰기 지연 저장소에 보관한다.
- 트랜잭션을 커밋하면 엔티티 매니저는 영속성 컨텍스트를 플러시한다.
  - 플러시는 영속성 컨텍스트의 변경 내용을 동기화하는 작업이다. 
  - 이 때 등록, 수정, 삭제한 엔티티를 데이터베이스에 반영한다.
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화한 후에 실제 데이터베이스 트랜잭션을 커밋한다.

## 변경 감지

```java
// 트랜잭션 시작
tx.begin();

// 영속 엔티티 조회
Member memberA = em.find(Member.class, 1L);

// 영속 엔티티 데이터 수정
memberA.setName("kim");

// 트랜잭션 커밋
tx.commit();
```

- 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터만 변경하면 된다.
- 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 변경 감지(Dirty checking)라 한다.

```text
    | 1차 캐시 |
*-------*--------*-------------*
|  @Id  | Entity |    스냅샷     |
*-------*--------*-------------*
|  1L   | Member | Member 스냅샷 |
*-------*--------*-------------*
```

JPA는 엔티티를 영속성 컨텍스트를 보환할 때 최초 상태를 복사해서 저장해두는데 이것을 스냅샷이라 한다.

- 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다.
- 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.
- 비영속, 준영속처럼 영속성 컨텍스트의 관리를 받지 못하는 엔티티는 값을 변경해도 데이터베이스에 반영되지 않는다.

#### 변경과정

1. 트랜잭션을 커밋하면 엔티티 매니저 내부에서 먼저 플러시가 호출된다.
2. 엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾는다.
3. 변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다.
4. 쓰기 지연 저장소의 SQL을 데이터베이스에 보낸다.
5. 데이터베이스 트랜잭션을 커밋한다.

JPA의 기본 전략은 엔티티의 모든 필드를 업데이트한다. (엔티티의 변경된 부분만 변경하지 않는다.)

모든 필드를 사용하면 데이터베이스에 보내는 데이터 전송량이 증가하는 단점이 있지만 다음과 같은 장점으로 인해 모든 필드를 업데이트한다.

- 수정 쿼리가 항상 같다. (애플리케이션 로딩 시점에 수정 쿼리를 미리 생성해주도 재사용할 수 있다)
- 데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 한 번 파싱된 쿼리를 재사용할 수 있다.

필드가 많거나 저장되는 내용이 너쿠 크면 수정된 데이터만 사용해 동적으로 UPDATE SQL을 생성하는 전략을 사용하면 된다.

```java
@Entity
@org.hibernate.annotation.DynamicUpdate
@Table(name = "Member")
public class Member { ... }
```

@org.hibernate.annotation.DynamicUpdate 어노테이션을 사용하면 수정된 데이터만 사용해 동적으로 UPDATE SQL를 생성한다.

- 데이터를 저장할 때 데이터가 존재하는 필드만으로 INSERT SQL을 생성하는 @DynamicInsert도 있다.

---

#### 참고

- [자바 ORM 표준 JPA 프로그래밍](http://www.yes24.com/Product/goods/19040233)